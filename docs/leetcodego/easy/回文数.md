##### No.9 Easy

***

- 思路

> :clock11:其实拿到题目的第一想法是转化为字符串进行判断，但是题目说进阶的话不让使用字符串；那么就得换一种思路了。
> 
> 1. 首先判断一下边界或者特殊情况：复数和0和末尾是0的整数，均是特殊情况，需要单独考虑。
> 
> 2. 非字符串的方法，脑子里第一印象蹦出来的就是通过对该数字取余10和除以10，从尾到头逐步拿到每一位的数字，再拼起来，拿到翻转之后的数字。

- 解法

> :rocket:举个例子，对于121来说
> 
> 1. 先取余10，拿到1，将1乘以10；
> 
> 2. 121除以10，变为12；
> 
> 3. 12取余10，拿到2，加上之前的10，再乘以10，得120；
> 
> 4. 12除以10，变为1（小于10的情况就结束循环操作）；
> 
> 5. 120加上1，得121；
> 
> 6. 和原来的数字相比即可。

:::tip 扩展阅读

如果反转后的数字大于 intMAX，我们将遇到整数溢出问题。

为了避免数字反转可能导致的溢出问题，考虑只反转 int 数字的一半。

关键点在于：如何知道反转数字的位数已经达到原始数字位数的一半？

由于整个过程我们不断将原始数字除以 `10`，然后给反转后的数字乘上 `10`，所以，当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。

![reverse](img\reverse.png)

```
class Solution {
    public boolean isPalindrome(int x) {
        if (x < 0 || (x % 10 == 0 && x != 0)) {
            return false;
        }
        int revertedNumber = 0;
        while (x > revertedNumber) {
            revertedNumber = revertedNumber * 10 + x % 10;
            x /= 10;
        }
        return x == revertedNumber || x == revertedNumber / 10;
    }
}
```

:::
